<!DOCTYPE html>
<html>
 <head><script src="/j/out"></script>
  <title>FUNC-007 Рекурсивные функции</title><meta charset="utf-8"><meta name="author" content="Iuliia Zhukova">
 </head>
 <body>
  <script src="/j/dblttl"></script>
  <script>{
    const sec = a => 1 + a;
    const add = (a, b) => (b === 0) ? a : sec(add(a, b - 1));
    const mpy = (a, b) => (b === 1) ? a : add(a, mpy(a, b - 1));
    // mpy(11,3) = 11 + mpy(11,2) = 11 + 11 + mpy(11,1) = 11 + 11 + 11 = 33
  	const pwr = (a, b) => ( b === 1) ? a : mpy(a, pwr(a,b-1));

    //Out.log(mpy(11, 3)); // 33
  	Out.log(pwr(5,5));
  /*
  Out.log(pwr(5,6)); - переполнение стека
  Pwr(5,5)
1.	add: (a, b) => (b === 0) ? a : sec(add(a, b - 1))
2.	mpy: (a, b) => (b === 1) ? a : add(a, mpy(a, b - 1))
3.	pwr: (a, b) => ( b === 1) ? a : mpy(a, pwr(a,b-1))
4.	sec: a => 1 + a
5pwr 33mpy 3125add sec 3125

  
  
  */
/*
   Допишите определение функции pwr от a и b, которая определяется через себя и mpy и выдаёт a ** b для положительных целых чисел.
   Выясните, при каких значениях аргументов наступает переполнение стека. Проиллюстрируйте это деревом вызовов, т.е. постройте дерево для последней комбинации значений аргументов pwr, при которой не происходит переполнения.
   Нам нужно выяснить, сколько раз вызывается при этом каждая из базовых функций (sec, add, mpy).
   
   Ранее: recur_task

*/
  
  
}</script>
 </body>
</html>